# storing-of-dates
#数据的存储
#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

//类型：1.使用这个类型开辟内存空间的大小（大小决定了使用范围）
//2.如何看待内存空间的视角
//int main()
//{
//	int a = 0;//4
//	float f = 10.0;//4
//	
//	short a = 10;
//	short int b = 10;
//	return 0;
//}
//void test()
//{
//	printf("hehe\n");
//}
//
//int main()
//{
//	test(100);
//	return 0;
//}

//int main()
//{
//	//无符号
//	int a = 20;//4个字节--32bit
//	//00000000000000000000000000010100 - 原码
//	//00000000000000000000000000010100 - 反码
//	//00000000000000000000000000010100 - 补码
//	//0x00000014十六进制
//
//	//有符号
//	int b = -10;
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101 - 反码
//	//11111111111111111111111111110110 - 补码
//	//0XFFFFFFF6
//	return 0;
//}

//int main()
//{
//	1 - 1;
//	//1+(-1)
//	//0000000000000000000000000000001   1的补码
//
//	//10000000000000000000000000000001  -1的原码
//	//11111111111111111111111111111110  -1的反码
//	//11111111111111111111111111111111  -1的补码
//
//	//00000000000000000000000000000000   计算结果1和-1的补码相加
//	return 0;
//
//}

//int main()
//{
//	int a = 20;
//	//000000000000000000000000000000010100
//	//0x00 00 00 14
//	//
//	return 0;
//}

//请简述大端字节和小端字节序的概念，设计一个小程序来判断当前机器的字节序。
//写一段代码告诉我们当前机器的字节序是什么
//int main()
//{
//	int a = 1;
//	//从“int*”到“char*”的类型不兼容，故强制转化
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//用函数来实现

//int check_sys()
//{
//	int a = 1;
//	char*p = (char*)&a;
//	if (*p == 1)
//		return 1;
//	else
//		return 0;
//}

//int check_sys()
//{
//	int a = 1;
//	char*p = (char*)&a;
//	//返回1，小端
//	//返回0，大端
//	return *p;
//}

//int check_sys()
//{
//	int a = 1;
//	
//	return *(char*)&a;
//}
//
//
//
//int main()
//{
//	//int a = 1;
//	////从“int*”到“char*”的类型不兼容，故强制转化
//	//char* p = (char*)&a;
//	//if (*p == 1)
//	//{
//	//	printf("小端\n");
//	//}
//	//else
//	//{
//	//	printf("大端\n");
//	//}
//	//返回1,小端
//	//返回0，大端
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//指针类型的意义
//1.指针类型决定了指针解引用操作符能访问几个字节：char*p;*p访问了1个字节，int*p;*p 访问4个字节
//2.指针类型决定了指针+！，-1，加的或减的是几个字节；char*p;p+1,跳过一个字符，int*p;p+1，跳过一个整形，4个字节

//int main()
//{
//	int a = 0x11223344;
//	int* p = &a;
//	*p = 0;
//	return 0;
//}

//int main()
//{
//	int a = 0x11223344;
//	char*p = &a;
//	*p = 0;
//	return 0;
//}

//练习
//1.输出什么？
int main()
{
	char a = -1;
	//-1在内存里存的是补码
	//10000000000000000000000000000001
	//11111111111111111111111111111110
	//11111111111111111111111111111111
	//-1的补码全是1
	//a只能存8个比特位  11111111
	//11111111

	signed char b = -1;
	//11111111

	unsigned char c = -1;//无符号，第一位就不是符号位
	//11111111
	//放进去相同，拿出来就不同了
	//拿出来就要开始补，char和signed补1
	//11111111111111111111111111111111
	//无符号unsigned就要补0了
	//00000000000000000000000011111111
	//0是正数，原码/反码/补码相同
	//255
	printf("a=%d,b=%d,c=%d",a, b, c);
	//-1 -1 255
	return 0;
}

//2.
int main()
{
	char a = -128;
	//10000000000000000000000010000000
	//11111111111111111111111101111111
	//11111111111111111111111110000000
	//32位补码存到a里只有八个比特位
	//10000000
	//11111111111111111111111110000000
	//本来是要将补码转换为原码输出，但%u就是要打印无符号的数，所以补码原码相同
	printf("%u\n", a);
	//%d-打印十进制的有符号数字
	//%u-打印十进制的无符号数字
	//4294967168
	return 0;
}



//3.
int main()
{
	char a = 128;//128就是127+1，也就是-128
	//00000000000000000000000010000000
	//11111111111111111111111101111111
	//11111111111111111111111110000000
	//10000000
	//00000000000000000000000010000000
	//11111111111111111111111101111111
	//11111111111111111111111110000000
	printf("%u\n", a);
	//4294967168
	return 0;
}

//4.
int main()
{
	int i = -20;
	//10000000000000000000000000010100
	//11111111111111111111111111101011
	//11111111111111111111111111101100

	unsigned int j = 10;
	//00000000000000000000000000001010
	//相加
	//11111111111111111111111111110110 - 结果
	//11111111111111111111111111110101
	//10000000000000000000000000001010 - -10
	printf("%d\n", i + j);//-10
	//按照补码的形式进行计算，最后格式化成为有符号整数
	return 0;
}

//5.
#include<Windows.h>
int main()
{
	unsigned int i;
	for (i = 9; i >=0; i--)
	{
		printf("%u\n", i);//9 8 7 6 5 4 3 2 1 死循环
		Sleep(100);//100毫秒等于0.1秒
	}
	return 0;
}

//6.
int main()
{
	 char a[1000];//0 - 999
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));//255
	//-1,-2,-3……-1000
	//但是char里只能存下-128~127之间，像-1000是存不下的
	//-1~-128，-129也就是127，126……0，0再减一变-1，……
	//所以这些数都是-128~127之间循环
	//-1~-128，1~127一共255个
	return 0;
	//strlen 求字符串长度找\0
}


//7.
unsigned char i = 0;//0-255
int main()
{
	for (i = 0; i <= 255; i++)//条件恒成立
	{
		printf("hello world\n");//死循环
	}
	return 0;
}

//强制转换
int a = 1;
char *p = (char*)&a;//int*

//浮点型在内存中的存储
//*********IEEE 754**********
//9.0
//1001.0
//（-1）^0*1.001*2^3          二进制是2的几次方，十进制就是十的几次方了
//（-1）^s*M*2^E
//s - 0
//M - 1.001
//E - 3
//
//0.5
//0.1  - 2^0 2^-1
// (-1)^0*1.0*2^-1
//s=0
//M=1.0
//E=-1
//E+127=126 

int main()
{
	int n = 9;
	float *pFloat = (float *)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("*pFlot的值为：%f\n",*pFloat);
	return 0;
}
//整型的形式放进去，整型的形式取出来没问题，但用浮点型的形式取出来就错误了
//浮点型的形式放进去，浮点型的形式取出来没问题，但用整型的形式取出来就错误了
int main()
{
	float f = 5.5;
	//5.5
	//101.1
	//(-1)^0*1.011*2^2
	//s=0
	//M=1.011
	//E=2
	//0 10000001 01100000000000000000000  2+127=129
	//0100 0000 1011 0000 0000 0000 0000 0000
	//0x40b00000
	//(-1)^0*1.011*2^2
	//129-127=2    129为E的存储值，2为E的真实值
	//
	//E全为0
	//0 00000000 01100000000000000000000
	//前面就不补1了直接补0
	//+/- 0.011*2^-126
	//
	//E为全1
	//0 11111111 01100000000000000000000
	//E+127=255
	//E=128
	//1.xxx*2^128  表示的正负无穷大的数字
	return 0;
}

int main()
{
	double d = 1E10;
	printf("%lf\n", d);

	return 0;
}

int main()
{
	int n = 9;
	//0 00000000 000000000000000001001 - 补码
	//
	float *pFloat = (float *)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
    //（-1）^0*0.000000000000000001001*2^-126
	//
	*pFloat = 9.0;
	//1001.0
	//1.001*2^3
	//(-1)^0*1.001*2^3
	//0 10000010 001000000000000000000
	//calc  计算器
	printf("num的值为：%d\n", n);//1091567616
	printf("*pFlot的值为：%f\n", *pFloat);//9.0
	return 0;
}
